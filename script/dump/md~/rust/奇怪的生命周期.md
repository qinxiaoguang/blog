概述
====

在学rust的时候，会对生命周期有很多奇怪的疑问，不明白其原理，不知道什么时候要用什么时候不要用，所以需要记录一下学习的心得，免得理解一个内容后又忘记。

什么时候会用到生命周期
======================

对于参数是引用，且返回类型也是引用时，需要使用生命周期，如果参数或者返回值都不是引用，就不需要生命周期，生命周期存在的本来的目的就是防止引用带来的程序bug，如悬垂指针等等，防止这些bug来达到系统安全的效果。

生命周期省略原则
================

1.  每个函数/方法的引用都会默认带有生命周期，以字母a,b依次类推
2.  如果一个函数只有一个引用参数，那么这个引用参数的默认生命周期会被赋值给所有的输出参数上。
3.  如果一个方法的第一个参数是 `&self`, `&mut self`
    ,则这个self的生命周期会被赋值给所有的输出参数上。

所有对于这些函数/方法，其不加生命周期是符合原则的

-   `fn test(&str) -> &str`
-   `fnt test(&self, &str) -> &str`

但是此时你可能会有疑问， 对于一个方法 `fn test(&self, &str) -> &str`
按照第三个原则，他的不省略生命周期的形式是这样的
`fn test(&'a self, b:&'b str) -> &'a str` 那么如果返回的值是
`b: &'b str` 会是什么效果呢，答案是编译不通过，如果返回的是具有 `b`
生命周期的参数，那么 `b` 的生命周期必须要和返回值 `&'a str` 的生命周期
`a` 有联系，如在方法前加上 `<'a:'b>` 表示 `a` 的生命周期要大于 `b` 。
所以，生命周期的存在是为了定义输入的参数和输出的参数的生命周期的联系，如果有不需要联系的生命周期，就可以不用加上生命周期的注解，如
`fn test(&'a self, b: &str)-> &str` 如果返回值只与 `a` 生命周期有关系，
对于b参数就不需要加生命周期注解(因为其与返回值无关联,
代码有无关联，编译器可以判断)
