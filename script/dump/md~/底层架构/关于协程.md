概述
====

在学了golang后，很喜欢其中的协程goroutine,对其实现方式也很有兴趣，经常思考，一个cpu内核开一个线程，是怎么对这些个协程进行调度的，所以去看了下源码，发现并不是很容易看懂，网上搜了很多文章，也不知其所以然，所以就又去看async/await的实现方法，在看async之前，一直以为协程就是轻量级线程，类似golang中的那样，但是看过async之后，总觉得async的用法怪怪得，跟golang的goroutine完全不一样，后来才发现是自己的理解有问题。

什么是协程
==========

协程是轻量级线程，其调度是在用户态完成的，即不是内核态或者说不是操作系统自己做的调度。
这里可以简单记录下三者的区别,首先有知道进程的调度是跟时间片有关的，这个是os关心的事情，只要知道os做了很多,进程很难被饿死就对了。不要限入了，某个进程会一直执行的思维里去了。

-   进程是在调度的时候必须进入内核态，其由操作系统进行调度，其有独立的上下文(PCB,process
    control
    blcok)，保存当前进程执行的上下文环境，有独立的地址空间，在调度的时候切换上下文会占用资源，所以其调度的花费时间较长。
-   线程是轻量级进程，一个进程里可以有多个线程，且共享该进程中的所有资源，每个线程又有自己的执行堆栈等信息，但没有独立的地址空间，线程在调度的时候切换上下文环境开销比进程小。
-   线程通常也分为用户线程和内核线程，内核线程通常是内核自己创建出来的线程，也叫守护线程，但内核线程只工作在内核态，没有用户空间，
-   进程是资源分配的最小单位，线程是程序执行的最小单位。
-   一个程序至少有一个进程，一个进程至少有一个线程(main),线程是进程里的一个执行单元,也是进程内的可调度的实体。一个线程挂掉，将导致整个进程挂掉。
-   进程间通信需要通过IPC的方式，此种方式有很多，如管道，信号量等，而同一进程下的线程通信可以通过共享变量等手段.
-   协程是由用户态线程进行调度。其核心思想
    ****控制流的主动让出和恢复****
    (yield,await等),必须在单线程中运行。golang中的gorotine其实严格来说并不是协程，而是另一种线程。
-   一般来说协程分为无栈协程(stackless)和有栈协程(stackful)，如python中的aysnc/await就属于无栈协程，而golang中的go
    func属于有栈协程。有栈其实就是在调度的时候将栈中的内容全部保存下来，所以可以将其看成另一种线程,或者用户态线程。
-   协程的含义是协作式调度，而golang的新版本的goroutine是通过抢占式调度实现的，所以严格意义上来说，goroutine不能叫做协程。
-   为什么golang里的协程可以支持数以万记的并发，原因在于golang里的协程内存分配只需4\~5kb(动态增长)，而在java中，jvm将线程委托给操作系统，每个线程的内存分配基本上是固定的(可配的),在64位系统中，jvm默认需要为一个线程分配1MB的内存空间,如果将默认值变小，则需要冒堆栈溢出的风险。所以协程可以分配的很多，且上下文切换时间也会相应的有所节省。上述是一个原因，还有一个原因是上下文切换，在java中线程的上下文切换需要从用户态切换到内核态并进行上下文切换，通常耗时1\~100us.在一个时钟为10us的cpu单核环境下，保证每个线程1s运行一次，那么1s内最多可运行100k个线程(按调度时间100us),而在golang中的协程不需要到内核态调度，所以几乎没有上下文切换的时间消耗。参考:<https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/>
    讲的很好
-   单线程中的async为什么比单线程sync优，原因在于单线程sync在执行io操作(即不占用cpu的任务)，或网络操作时，会阻塞，而async可以执行另外的代码，不发生阻塞，所以async要比sync快，但是如果所有的代码都是关于cpu的，不发生阻塞，那么使用sync是比async优的，所以其面向的场景并不同。

我自己还纳闷，golang里，一个线程里不开辟新的空间，不替换寄存器的时候，单条流运行到底是怎么实现多个协程的调度的，现在算是明白了一点。

为什么协程比线程快
==================

考虑微观情况，在单核的cpu下，同一时间只有一个程序在运行。那么在多线程的情况下，这些线程串行完成任务和并行完成任务并没有什么区别，但为什么并行的就是比串行完成任务快呢。同样的道理，为什么在大多数情况下协程比线程快呢。
其实，相对来说运行速度 协程\>线程\>进程
快的原因在于调度，多进程运行的时候，其调度的时候会进行上下文切换，进程的上下文切换会先进入内核态，用户态到内核态的切换会消耗时间，而上下文切换(内存，pcb,栈等等)更会消耗时间。而线程的上下文切换却比进程小很多，虽然其也会进入到内核态，但是因为同进程下的线程间共享内存及其他内容，所以其切换的时间是小于进程的。同样的，协程因为是轻量级线程，其主要主旨是
****控制流的主动让出和恢复****,所以协程在运行的时候，其发生的调度的机率比较小，原因在于遇到一些阻塞的情况，会主动让出资源，不发生(内核)调度，再有协程是用户态线程，所以协程的调度是在用户态进行的，不会切换到内核态，
所以他相对线程来说，节约的是用户态到内核态及上下文切换的时间.

参考
====

<https://jiajunhuang.com/articles/2018_04_03-coroutine.md.html>
