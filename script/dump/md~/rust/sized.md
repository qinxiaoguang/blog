解释
====

rust在编译时就要知道类型的实际大小。而很多类型只有在运行时才能确定大小，如\"str\"类型及部分trait。

像这些在编译时不能确定其大小的类型，叫动态大小类型。其有一个黄金规则:必须将动态大小类型的值置于某种指针之后。如str类型不能直接被创建，像代码
`let s:str = "aaa"` 是不被允许的，但可以将其放在指针后,如
`let s:&str = "aaa"`
,当然智能指针也是指针的一种，所以Box\<str\>,Rc\<str\>也是合法的。

Rust 有一个特定的 trait
来决定一个类型的大小是否在编译时可知，这就是Sized,
其表示某个类型在编译器能确定大小。Rust 隐式的为每一个泛型函数增加了
`Sized bound`, 即 `fn test<T>(t:T)` 会被自动编译为
`fn test<T:Sized>(t:T)`, 而与 `Sized` 相对立的还有一个类型是 `?Sized`,
这种语法只能用在 `Sized` 上，其表示对应的类型可能是 `Sized`
也可能不是。所以对于 `?Sized`
类型来说，在泛型函数上，只能将类型用在指针后，因为在编译时不确定其类型大小，即
`fn test<T:?Sized>test(t:&T)`
