定义宏
======

常用的定义宏的方式 eg:

``` {.rust}
#[macro_export] // 表明宏是可导出的，可被外部使用的
macro_rules! vec2 { 
    // 位于大括号内部的就是宏的定义体，其结构与match类似，会有模式匹配，如vec![1,2,3]就与下方的( $( $x:expr ),* )匹配，所以会执行对应的代码块。但是宏匹配的不是值，而是代码结果。
    ( $( $x:expr ),* ) => {  // $( $x:expr ) expr表示任意表达式,x则是匹配的变量，在代码块中会用到。而后边跟着逗号，则表示一个逗号分隔符可以有选择的出现代码$()之后，* 说明该模式匹配零个或多个 * 之前的任何模式
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )* // 与前边的 $( $x:expr ),* 相呼应 
            temp_vec
        }
    };
}
```

写几个神奇的macro:

``` {.rust}
macro_rules! v {
    ($fn:expr => $id2:ident  <- [$start:expr; $end:expr]) => {{
        let mut vec = Vec::new();
        for num in $start..$end {
            vec.push($fn(num));
        }
        vec
    }};
}

// 用法: v![ |x|x+x => x <- [0;10]]
```

派生宏
======

即使用 `#[derive()]` 的宏：示例结构:

``` {.rust}
hello_macro
├── Cargo.lock
├── Cargo.toml
├── hello_macro_derive  // 实现宏的包
│   ├── Cargo.lock
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── src
│   └── lib.rs
└── target
    ├── debug
    └── rls
```

其中在hello~macro~/src/lib.rs中代码如:

``` {.rust}
//该包下的trait起到类似声明的含义
pub trait HelloMacro {
    fn hello_macro();
}
```

在hello~macro~/hello~macroderive~/cargo.toml中加入,实现派生宏需要三个包:proc~macro~,syn,quote,其中proc~macro是自带的~:

``` {.rust}

[lib]
proc-macro = true

[dependencies]
syn = "0.14.4"
quote = "0.6.3"
```

在hello~macro~/hello~macroderive~/src/lib.rs中添加如下代码:

``` {.rust}
extern crate proc_macro;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)] // 生成HelloMacro,会自动生成trait HelloMacro,所以前边的包中的trait HelloMacro不能添加到这个包中
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // 构建 Rust 代码所代表的语法树
    // 以便可以进行操作
    let ast = syn::parse(input).unwrap();

    // 构建 trait 实现
    impl_hello_macro(&ast)
}

fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! { // quote包含的是希望生成的代码
        impl HelloMacro for #name { // #name 用name的值 来替换
            fn hello_macro() {
                println!("这是生成的代码?");
                println!("Hello, Macro! My name is {}", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

使用时，将上述两个包都导入即可，如:

``` {.rust}
[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" 
```

而此时就可以通过 `#[derive(HelloMacro)]` 来进行派生了

类属性宏
========

与派生宏类似，只不过在实现的时候将\#\[proc~macroderive~(xx)\]换成\#\[proc~macroattribute~\]而对应的方法名则为属性宏的名称，如:

``` {.rust}
#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {
```

其他保持不变即可，同样也是通过quote!来生成你想要的代码。之后就可以使用该宏进行注解，如:

``` {.rust}
#[route(GET, "/")]
fn index() {
```
