背景
====

在学习一门新的语言的时候,经常会被其中的IO
操作,如阻塞,非阻塞,同步,异步搞迷糊,也经常不知道这些名词的使用场景.假如有一个单核单
CPU 计算器,他的异步操作会比同步操作快么,为什么?
基于此,想要重新补充下操作系统的知识,于是找到了该书籍,不仅能学到 linux
的知识,也能学到操作系统的细节,一举两得.

心得
====

硬件
----

1.  IO 操作不单单之读写文件,也指 CPU
    与各个部件的交互,如对显存的读写,对键盘的读写等等,基本上与 CPU
    交互的都可以称为是 IO 部件.
2.  与 CPU
    连接的线(总线)有三条,分别是数据线,地址线及控制线,他们的作用分别是:数据线用于传输数据,地址线用于寻址,控制线用于控制读写.
3.  与 CPU 交互的 IO
    部件的地址可以理解为统一编址,如显存的地址可以用一个统一的地址表示,如果要向屏幕显示一个字符,可以使用汇编指令向该统一地址写入数据,即先使用地址线寻址(统一地址),
    控制线控制写,在通过数据线写入数据.
4.  通过 `cat /proc/ioports` 可以查看 各个控制器的 IO 地址范围.
5.  DMA(Direct Memeory Access) 是用于 IO 设备与内存间的直接交互,
    整个过程只需要 DMA 控制器执行,不需要经过 CPU 插手
6.  一些定时/计数器可被编程,如每10ms
    发送一个中断信号,所以不同的操作系统的定时器的实现是不一样的.

地址
----

1.  逻辑地址,是程序员与之打交道的地址,并不是实际的物理地址
2.  线性地址,逻辑地址向物理地址转换的中间层,通常会通过分段机制,将逻辑地址转换为线性地址
3.  物理地址,若开启了分页机制,则会将线性地址转换为物理地址,若未开启分页机制,则线性地址则为物理地址,
    分页机制使用的场景是内存 被分为零散的块

系统调用
--------

1.  系统调用是Linux内核与
    上层应用程序进行交互的唯一接口,系统调用可以使用内核资源,所以一些库函数可以通过系统调用间接使用内核资源,
    一般在系统调用开始时会进行中断操作(汇编指令int)
2.  系统每隔10ms
    会发送一个中断请求信号,这个就是系统运行的脉搏,称其为一个系统时钟周期.时钟中断处理程序在中断时会将对应的变量+1,来标记过了多少个时钟周期,同时运行
    do~timer~() 函数,
    其会探测当前进程运行的时间片(通常即为一个时钟周期),若时间片\>0,则当前
    进程未执行完毕,则直接退出 do~timer~ 继续执行,若时间片=0,
    则其会判断当前进程是否为内核态,若为内核态,则其直接退出
    do~timer~,若为用户态,则调用 schedule 函数来选择下一个要运行的进程.
    由此可见,内核态的进程是不会被抢占的.(但是后续升级的内核,低优先级的进程是可以被高优先级的抢占)

进程
----

1.  一个进程可以在内核态运行,也可以在用户态运行,
    当进程在执行用户代码时,其就是运行态.
2.  内核程序通过进程表对进程进行管理,其表中的每个项是一个 task~struct~
    的指针,指向的是 PCB(Process Control Block)
3.  进程的状态
    ![](http://q.qxgzone.com/static/img/linux内核完全剖析学习笔记_linux_state.png)
4.  内核态,用户态以及就绪态在系统中的表示都是 task~runnin~
5.  可中断睡眠态可被中断唤醒,不可被调度,不可中断睡眠态,只能通过 wake~up~
    函数唤醒
6.  暂停状态(task~stopped~)是用来进行调试,僵死状态是进程已运行结束,但是副进程还未访问其状态,当父进程调用
    wait 方法获取了子进程的信息后,该状态的进程的数据就会被释放掉
7.  内核态不会被抢占,若内核态执行时需要等待某个资源则会调用 sleep~on~ 或
    interruptible~sleepon~ 自愿放弃 cpu
    使用权,并进入睡眠态,只有内核态转移到睡眠态的,内核才能进行进程切换操作,内核在执行临界区代码时,禁止一切中断
8.  在创建进程后,一般会为其分配一个内存页,但子进程首先会共享父进程的内存页,只有在有写内存的操作时,才为子进程分配独自使用的内存页,这种处理被称为写时复制技术
9.  linux0.11中的进程调度采用的是基于优先队列的调度策略,其会扫描当前所有处于
    task~running~ 状态的进程,比较其 counter(运行时间)
    值来确定哪个进程的运行时间最少,于是就选中该进程(counter值越高).
    若所有的 task~running~
    的进程的时间片都使用完毕,则重新计算每个进程需要的运行的时间片
    计算方式是 counter=couter/2+priority,
    这样对于正在睡眠的进程被唤醒时就具有较高的 counter
    值,可优先被选中.若没有进程选中,则调用进程0(根进程,其他进程都是直接或间接从根进程复制而来)

文件系统
--------

1.  所有对文件系统中数据的访问,
    或者对块设备的访问,都需要首先读取到内存高速缓冲区中,而在读数据的时候,首先在高速缓冲区查看是否有数据,如果有则直接读取,
    高速缓冲区是内存中的一块区域,位于内核代码块和主内存之间,其被划分为1024字节的缓冲块
2.  对于 linux
    系统,所有输入输出都是通过读写文件完成的,因为所有的设备都是以文件形式在系统中呈现,通常会通过文件描述符与该文件进行交互,文件描述符(fd)和文件句柄的作用一样
